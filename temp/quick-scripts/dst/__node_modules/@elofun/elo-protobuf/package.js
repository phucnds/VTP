
                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/@elofun/elo-protobuf/package.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var buffer_1 = require("buffer/");
var buffer_reader_1 = require("./buffer-reader");
var buffer_writer_1 = require("./buffer-writer");
var types_1 = require("./types");
var ELOPackage = /** @class */ (function () {
    function ELOPackage() {
    }
    ELOPackage.unpack = function (schema, buffer, reader) {
        var bufferReader;
        if (!reader) {
            // restore bytes
            var length_1 = buffer.length;
            var bufLength = length_1 - 1;
            var checksum = 0;
            for (var i = 0; i < bufLength; i++) {
                buffer[i] = (((buffer[i] - length_1 - i) % 256) + 256) % 256;
                checksum += buffer[i];
            }
            checksum = checksum % 256;
            if (checksum !== buffer[bufLength]) {
                throw new Error("Invalid package!");
            }
            ELOPackage._sBufferReader.reset(buffer);
            bufferReader = ELOPackage._sBufferReader;
        }
        else {
            bufferReader = reader;
        }
        var data = {};
        Object.keys(schema).forEach(function (key) {
            var type = schema[key];
            switch (type) {
                case types_1.INT8:
                case types_1.INT16:
                case types_1.INT32:
                case types_1.UINT8:
                case types_1.UINT16:
                case types_1.UINT32:
                case types_1.BOOL:
                case types_1.FLOAT:
                    data[key] = bufferReader.readByType(type);
                    break;
                case types_1.BINARY:
                    data[key] = bufferReader.readBinary();
                    break;
                default:
                    if (type instanceof Array || Array.isArray(type)) {
                        var count = bufferReader.readUInt16();
                        var subSchema = type[0];
                        if (!count || !subSchema) {
                            return;
                        }
                        if (typeof subSchema === "object") {
                            var items = [];
                            for (var i = 0; i < count; i++) {
                                items.push(ELOPackage.unpack(subSchema, buffer, bufferReader));
                            }
                            data[key] = items;
                        }
                        else if (subSchema === types_1.ELOTypes.BINARY) {
                            var items = [];
                            for (var i = 0; i < count; i++) {
                                items.push(bufferReader.readBinary());
                            }
                            data[key] = items;
                        }
                        else {
                            var items = [];
                            for (var i = 0; i < count; i++) {
                                items.push(bufferReader.readByType(subSchema));
                            }
                            data[key] = items;
                        }
                    }
                    else if (typeof type === "object") {
                        data[key] = ELOPackage.unpack(type, buffer, bufferReader);
                    }
                    break;
            }
        });
        return data;
    };
    ELOPackage.pack = function (schema, data, writer) {
        var bufferWriter;
        var packSchema = schema;
        data = __assign({}, data);
        if (!writer) {
            ELOPackage._sBufferWriter.reset();
            bufferWriter = ELOPackage._sBufferWriter;
            packSchema = __assign(__assign({}, schema), { __checkSum: types_1.UINT8 });
            data["__checkSum"] = 0;
        }
        else {
            bufferWriter = writer;
        }
        Object.keys(packSchema).forEach(function (key) {
            var type = packSchema[key];
            switch (type) {
                case types_1.INT8:
                case types_1.INT16:
                case types_1.INT32:
                case types_1.UINT8:
                case types_1.UINT16:
                case types_1.UINT32:
                case types_1.BOOL:
                case types_1.FLOAT:
                    bufferWriter.writeByType(type, data[key]);
                    break;
                case types_1.BINARY:
                    bufferWriter.writeBinary(data[key]);
                    break;
                default:
                    if (Array.isArray(type)) {
                        var items = data[key];
                        bufferWriter.writeUInt16(items.length);
                        var subSchema = type[0];
                        if (!subSchema) {
                            return;
                        }
                        if (typeof subSchema === "object") {
                            for (var i = 0; i < items.length; i++) {
                                ELOPackage.pack(subSchema, items[i], bufferWriter);
                            }
                        }
                        else if (subSchema === types_1.ELOTypes.BINARY) {
                            for (var i = 0; i < items.length; i++) {
                                var val = items[i];
                                bufferWriter.writeBinary(val);
                            }
                        }
                        else {
                            for (var i = 0; i < items.length; i++) {
                                var val = items[i];
                                bufferWriter.writeByType(subSchema, val);
                            }
                        }
                    }
                    else if (typeof type === "object") {
                        var item = data[key];
                        ELOPackage.pack(type, item, bufferWriter);
                    }
                    break;
            }
        });
        var buffer = bufferWriter.getBuffer();
        if (!writer) {
            var length_2 = buffer.length;
            var bufLength = length_2 - 1;
            var checksum = 0;
            for (var i = 0; i < bufLength; i++) {
                checksum += buffer[i];
                buffer[i] = (buffer[i] + length_2 + i) % 256;
            }
            buffer[bufLength] = checksum % 256;
        }
        return buffer;
    };
    ELOPackage._sBufferReader = new buffer_reader_1.ELOBufferReader(buffer_1.Buffer.alloc(0));
    ELOPackage._sBufferWriter = new buffer_writer_1.ELOBufferWriter(buffer_1.Buffer.alloc(1024 * 1024));
    return ELOPackage;
}());
exports.ELOPackage = ELOPackage;

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();