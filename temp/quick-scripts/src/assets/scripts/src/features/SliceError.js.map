{"version":3,"sources":["assets/scripts/src/features/SliceError.ts"],"names":[],"mappings":";;;;;;;;AAAA,4CAA8D;AAC9D,8CAAkE;AAWlE,IAAM,cAAc,GAAgB;IAChC,IAAI,EAAE,EAAE;IACR,aAAa,EAAE,SAAS;CAC3B,CAAC;AACF,IAAM,KAAK,GAAG,qBAAW,CAAC;IACtB,IAAI,EAAE,OAAO;IACb,YAAY,EAAE,cAAc;IAC5B,QAAQ,EAAE;QACN,SAAS,EAAT,UAAU,KAAK,EAAE,EAAuC;gBAArC,OAAO,aAAA;YACtB,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;YACzB,IAAI,SAAS,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAA;YAC7B,SAAS,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,IAAI,IAAI,2BAAe,CAAC,MAAM,EAAhC,CAAgC,CAAC,CAAA;YAClE,IAAI,CAAC,SAAS;gBAAE,SAAS,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,IAAI,IAAI,2BAAe,CAAC,KAAK,EAA/B,CAA+B,CAAC,CAAA;YACjF,IAAI,CAAC,SAAS;gBAAE,SAAS,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,IAAI,IAAI,2BAAe,CAAC,KAAK,EAA/B,CAA+B,CAAC,CAAA;YACjF,IAAI,CAAC,SAAS;gBAAE,SAAS,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,IAAI,IAAI,2BAAe,CAAC,YAAY,EAAtC,CAAsC,CAAC,CAAA;YACxF,KAAK,CAAC,aAAa,GAAG,SAAS,CAAA;QACnC,CAAC;QACD,YAAY,YAAC,KAAK;YACd,KAAK,CAAC,IAAI,GAAG,EAAE,CAAA;YACf,KAAK,CAAC,aAAa,GAAG,SAAS,CAAA;QACnC,CAAC;KACJ;CACJ,CAAC,CAAA;AAEa,QAAA,SAAS,IAAX,KAA8B,KAAK,CAAC,OAAO,iBAA9B,QAAA,YAAY,mBAAmB;AAEzD,kBAAe,KAAK,CAAC,OAAO,CAAC","file":"","sourceRoot":"/","sourcesContent":["import { createSlice, PayloadAction } from \"@reduxjs/toolkit\";\nimport { ErrorHandleType, IAPIInterface } from \"../app/APIDefine\";\nexport interface IErrorHanle {\n    type: ErrorHandleType,\n    errorCode: string,\n    api: IAPIInterface,\n}\nexport interface IErrorState {\n    list: IErrorHanle[],\n    currentHandle: IErrorHanle,\n}\n\nconst initErrorState: IErrorState = {\n    list: [],\n    currentHandle: undefined\n};\nconst error = createSlice({\n    name: 'error',\n    initialState: initErrorState,\n    reducers: {\n        pushError(state, { payload }: PayloadAction<IErrorHanle>) {\n            state.list.push(payload);\n            let handleMax = state.list[0]\n            handleMax = state.list.find(e => e.type == ErrorHandleType.RELOAD)\n            if (!handleMax) handleMax = state.list.find(e => e.type == ErrorHandleType.RETRY)\n            if (!handleMax) handleMax = state.list.find(e => e.type == ErrorHandleType.CLOSE)\n            if (!handleMax) handleMax = state.list.find(e => e.type == ErrorHandleType.BACK_TO_HOME)\n            state.currentHandle = handleMax\n        },\n        refreshError(state) {\n            state.list = []\n            state.currentHandle = undefined\n        }\n    }\n})\n\nexport const { pushError, refreshError } = error.actions;\n\nexport default error.reducer;"]}